//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.0.1.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import axios, { AxiosError } from 'axios';
import type { AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

export class AccountClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    get( cancelToken?: CancelToken): Promise<AppAccount> {
        let url_ = this.baseUrl + "/api/account";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<AppAccount> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<AppAccount>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AppAccount>(null as any);
    }

    refresh( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/account/refresh";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRefresh(_response);
        });
    }

    protected processRefresh(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    isSigninWithGoogleSupported( cancelToken?: CancelToken): Promise<boolean> {
        let url_ = this.baseUrl + "/api/account/is-signin-with-google-supported";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processIsSigninWithGoogleSupported(_response);
        });
    }

    protected processIsSigninWithGoogleSupported(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    signInWithGoogle( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/account/signin-with-google";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSignInWithGoogle(_response);
        });
    }

    protected processSignInWithGoogle(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    signOut( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/account/sign-out";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSignOut(_response);
        });
    }

    protected processSignOut(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    isSubscriptionOrderProcessed(providerOrderId: string, cancelToken?: CancelToken): Promise<boolean> {
        let url_ = this.baseUrl + "/api/account/subscription-orders/providerOrderId:{providerOrderId}/is-processed";
        if (providerOrderId === undefined || providerOrderId === null)
            throw new Error("The parameter 'providerOrderId' must be defined.");
        url_ = url_.replace("{providerOrderId}", encodeURIComponent("" + providerOrderId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processIsSubscriptionOrderProcessed(_response);
        });
    }

    protected processIsSubscriptionOrderProcessed(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    getAccessKeys(subscriptionId: string, cancelToken?: CancelToken): Promise<string[]> {
        let url_ = this.baseUrl + "/api/account/subscriptions/{subscriptionId}/access-keys";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAccessKeys(_response);
        });
    }

    protected processGetAccessKeys(response: AxiosResponse): Promise<string[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<string[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string[]>(null as any);
    }
}

export class AppClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    configure(configParams: ConfigParams, cancelToken?: CancelToken): Promise<AppConfig> {
        let url_ = this.baseUrl + "/api/app/configure";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(configParams);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PATCH",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processConfigure(_response);
        });
    }

    protected processConfigure(response: AxiosResponse): Promise<AppConfig> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<AppConfig>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AppConfig>(null as any);
    }

    getConfig( cancelToken?: CancelToken): Promise<AppConfig> {
        let url_ = this.baseUrl + "/api/app/config";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetConfig(_response);
        });
    }

    protected processGetConfig(response: AxiosResponse): Promise<AppConfig> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<AppConfig>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AppConfig>(null as any);
    }

    getState( cancelToken?: CancelToken): Promise<AppState> {
        let url_ = this.baseUrl + "/api/app/state";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetState(_response);
        });
    }

    protected processGetState(response: AxiosResponse): Promise<AppState> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<AppState>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AppState>(null as any);
    }

    connect(clientProfileId?: string | null | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/app/connect?";
        if (clientProfileId !== undefined && clientProfileId !== null)
            url_ += "clientProfileId=" + encodeURIComponent("" + clientProfileId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processConnect(_response);
        });
    }

    protected processConnect(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    diagnose(clientProfileId?: string | null | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/app/diagnose?";
        if (clientProfileId !== undefined && clientProfileId !== null)
            url_ += "clientProfileId=" + encodeURIComponent("" + clientProfileId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDiagnose(_response);
        });
    }

    protected processDiagnose(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    disconnect( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/app/disconnect";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDisconnect(_response);
        });
    }

    protected processDisconnect(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    clearLastError( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/app/clear-last-error";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processClearLastError(_response);
        });
    }

    protected processClearLastError(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    setUserSettings(userSettings: UserSettings, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/app/user-settings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(userSettings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSetUserSettings(_response);
        });
    }

    protected processSetUserSettings(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    log( cancelToken?: CancelToken): Promise<string> {
        let url_ = this.baseUrl + "/api/app/log.txt";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processLog(_response);
        });
    }

    protected processLog(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<string>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }

    getInstalledApps( cancelToken?: CancelToken): Promise<DeviceAppInfo[]> {
        let url_ = this.baseUrl + "/api/app/installed-apps";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetInstalledApps(_response);
        });
    }

    protected processGetInstalledApps(response: AxiosResponse): Promise<DeviceAppInfo[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<DeviceAppInfo[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DeviceAppInfo[]>(null as any);
    }

    getIpGroups( cancelToken?: CancelToken): Promise<IpGroup[]> {
        let url_ = this.baseUrl + "/api/app/ip-groups";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetIpGroups(_response);
        });
    }

    protected processGetIpGroups(response: AxiosResponse): Promise<IpGroup[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<IpGroup[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<IpGroup[]>(null as any);
    }

    versionCheck( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/app/version-check";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processVersionCheck(_response);
        });
    }

    protected processVersionCheck(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    versionCheckPostpone( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/app/version-check-postpone";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processVersionCheckPostpone(_response);
        });
    }

    protected processVersionCheckPostpone(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    addAccessKey(accessKey: string, cancelToken?: CancelToken): Promise<ClientProfileInfo> {
        let url_ = this.baseUrl + "/api/app/access-keys?";
        if (accessKey === undefined || accessKey === null)
            throw new Error("The parameter 'accessKey' must be defined and cannot be null.");
        else
            url_ += "accessKey=" + encodeURIComponent("" + accessKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAddAccessKey(_response);
        });
    }

    protected processAddAccessKey(response: AxiosResponse): Promise<ClientProfileInfo> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<ClientProfileInfo>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ClientProfileInfo>(null as any);
    }

    updateClientProfile(clientProfileId: string, updateParams: ClientProfileUpdateParams, cancelToken?: CancelToken): Promise<ClientProfileInfo> {
        let url_ = this.baseUrl + "/api/app/client-profiles/{clientProfileId}";
        if (clientProfileId === undefined || clientProfileId === null)
            throw new Error("The parameter 'clientProfileId' must be defined.");
        url_ = url_.replace("{clientProfileId}", encodeURIComponent("" + clientProfileId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateParams);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PATCH",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateClientProfile(_response);
        });
    }

    protected processUpdateClientProfile(response: AxiosResponse): Promise<ClientProfileInfo> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<ClientProfileInfo>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ClientProfileInfo>(null as any);
    }

    deleteClientProfile(clientProfileId: string, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/app/client-profiles/{clientProfileId}";
        if (clientProfileId === undefined || clientProfileId === null)
            throw new Error("The parameter 'clientProfileId' must be defined.");
        url_ = url_.replace("{clientProfileId}", encodeURIComponent("" + clientProfileId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteClientProfile(_response);
        });
    }

    protected processDeleteClientProfile(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class BillingClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    getSubscriptionPlans( cancelToken?: CancelToken): Promise<SubscriptionPlan[]> {
        let url_ = this.baseUrl + "/api/billing/subscription-plans";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetSubscriptionPlans(_response);
        });
    }

    protected processGetSubscriptionPlans(response: AxiosResponse): Promise<SubscriptionPlan[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<SubscriptionPlan[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SubscriptionPlan[]>(null as any);
    }

    purchase(planId: string, cancelToken?: CancelToken): Promise<string> {
        let url_ = this.baseUrl + "/api/billing/purchase?";
        if (planId === undefined || planId === null)
            throw new Error("The parameter 'planId' must be defined and cannot be null.");
        else
            url_ += "planId=" + encodeURIComponent("" + planId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPurchase(_response);
        });
    }

    protected processPurchase(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<string>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }
}

export interface AppAccount {
    userId: string;
    name?: string | null;
    email?: string | null;
    subscriptionId?: string | null;
    providerPlanId?: string | null;
}

export interface AppConfig {
    features: AppFeatures;
    settings: AppSettings;
    state: AppState;
    clientProfileInfos: ClientProfileInfo[];
    availableCultureInfos: UiCultureInfo[];
}

export interface AppFeatures {
    version: string;
    isExcludeAppsSupported: boolean;
    isIncludeAppsSupported: boolean;
    updateInfoUrl?: string | null;
    uiName?: string | null;
    isAddAccessKeySupported: boolean;
    builtInAccessTokenId?: string | null;
}

export interface AppSettings {
    version: number;
    isQuickLaunchAdded: boolean;
    isQuickLaunchRequested: boolean;
    configTime: Date;
    userSettings: UserSettings;
    clientId: string;
    lastCountryIpGroupId?: string | null;
    lastUpdateCheckTime?: Date | null;
}

export interface UserSettings {
    logging: AppLogSettings;
    cultureCode?: string | null;
    clientProfileId?: string | null;
    maxReconnectCount: number;
    maxDatagramChannelCount: number;
    tunnelClientCountry: boolean;
    ipGroupFilters?: string[] | null;
    ipGroupFiltersMode: FilterMode;
    customIpRanges?: string[] | null;
    appFilters?: string[] | null;
    appFiltersMode: FilterMode;
    useUdpChannel: boolean;
    dropUdpPackets: boolean;
    excludeLocalNetwork: boolean;
    packetCaptureIncludeIpRanges: string[];
    packetCaptureExcludeIpRanges?: string[] | null;
    allowAnonymousTracker: boolean;
    dnsServers?: string[] | null;
}

export interface AppLogSettings {
    logToConsole: boolean;
    logToFile: boolean;
    logVerbose: boolean;
    logAnonymous: boolean;
}

export enum FilterMode {
    All = "All",
    Exclude = "Exclude",
    Include = "Include",
}

export interface AppState {
    configTime: Date;
    connectRequestTime?: Date | null;
    connectionState: AppConnectionState;
    lastError?: string | null;
    clientProfileId?: string | null;
    isIdle: boolean;
    logExists: boolean;
    hasDiagnoseStarted: boolean;
    hasDisconnectedByUser: boolean;
    hasProblemDetected: boolean;
    sessionStatus?: SessionStatus | null;
    speed: Traffic;
    sessionTraffic: Traffic;
    accountTraffic: Traffic;
    clientIpGroup?: IpGroup | null;
    isWaitingForAd: boolean;
    versionStatus: VersionStatus;
    lastPublishInfo?: PublishInfo | null;
    isUdpChannelSupported?: boolean | null;
    canDisconnect: boolean;
    canConnect: boolean;
    currentUiCultureInfo: UiCultureInfo;
    systemUiCultureInfo: UiCultureInfo;
}

export enum AppConnectionState {
    None = "None",
    Initializing = "Initializing",
    Waiting = "Waiting",
    Diagnosing = "Diagnosing",
    Connecting = "Connecting",
    Connected = "Connected",
    Disconnecting = "Disconnecting",
}

export interface SessionStatus {
    errorCode: SessionErrorCode;
    accessUsage?: AccessUsage | null;
    suppressedTo: SessionSuppressType;
    suppressedBy: SessionSuppressType;
    errorMessage?: string | null;
    isAdRequired: boolean;
}

export enum SessionErrorCode {
    Ok = "Ok",
    GeneralError = "GeneralError",
    SessionClosed = "SessionClosed",
    SessionSuppressedBy = "SessionSuppressedBy",
    SessionError = "SessionError",
    AccessExpired = "AccessExpired",
    AccessTrafficOverflow = "AccessTrafficOverflow",
    AccessLocked = "AccessLocked",
    AccessError = "AccessError",
    AdError = "AdError",
    Maintenance = "Maintenance",
    RedirectHost = "RedirectHost",
    UnsupportedClient = "UnsupportedClient",
    UnsupportedServer = "UnsupportedServer",
}

export interface AccessUsage {
    traffic: Traffic;
    maxTraffic: number;
    expirationTime?: Date | null;
    maxClientCount: number;
    activeClientCount?: number | null;
}

export interface Traffic {
    sentTraffic: number;
    receivedTraffic: number;
    sent: number;
    received: number;
}

export enum SessionSuppressType {
    None = "None",
    YourSelf = "YourSelf",
    Other = "Other",
}

export interface IpGroup {
    ipGroupId: string;
    ipGroupName: string;
}

export enum VersionStatus {
    Unknown = "Unknown",
    Latest = "Latest",
    Old = "Old",
    Deprecated = "Deprecated",
}

export interface PublishInfo {
    version: string;
    updateInfoUrl: string;
    packageUrl: string;
    googlePlayUrl?: string | null;
    installationPageUrl: string;
    releaseDate: Date;
    deprecatedVersion: string;
    notificationDelay: string;
}

export interface UiCultureInfo {
    code: string;
    nativeName: string;
}

export interface ClientProfileInfo {
    clientProfileId: string;
    clientProfileName: string;
    tokenId: string;
    supportId?: string | null;
    hostNames: string[];
    isValidHostName: boolean;
    regions: HostRegion[];
}

export interface HostRegion {
    regionId: string;
    regionName?: string | null;
    countryCode?: string | null;
}

export interface ConfigParams {
    availableCultures: string[];
    strings?: AppStrings | null;
}

export interface AppStrings {
    appName: string;
    disconnect: string;
    connect: string;
    disconnected: string;
    exit: string;
    manage: string;
    msgAccessKeyAdded: string;
    msgAccessKeyUpdated: string;
    msgCantReadAccessKey: string;
    msgUnsupportedContent: string;
    msgCantShowAd: string;
    open: string;
    openInBrowser: string;
}

export interface DeviceAppInfo {
    appId: string;
    appName: string;
    iconPng: string;
}

export interface ClientProfileUpdateParams {
    clientProfileName?: PatchOfString | null;
    regionId?: PatchOfString | null;
}

export interface PatchOfString {
    value?: string | null;
}

export interface SubscriptionPlan {
    subscriptionPlanId: string;
    planPrice: string;
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

function isAxiosError(obj: any): obj is AxiosError {
    return obj && obj.isAxiosError === true;
}

export class ApiException extends Error {
    statusCode: number;
    response?: string;
    exceptionTypeName?: string;
    exceptionTypeFullName?: string;
    headers: any;
    data: any = {};

    constructor(
        message: string,
        statusCode: number,
        response?: any,
        headers?: any,
        innerException?: Error | null
    ) {
        if (!(response instanceof String)) response = JSON.stringify(response);
        super(ApiException.buildMessage(message, statusCode, response));
        Object.setPrototypeOf(this, ApiException.prototype);

        this.statusCode = statusCode;
        this.response = response;
        this.headers = headers;

        let serverException: ServerException | null = ServerException.tryParse(response);
        if (serverException) {
            Object.keys(serverException.Data).forEach((key) => {
                if (serverException)
                    this.data[key] = serverException.Data[key];
            });
            this.exceptionTypeName = serverException.TypeName;
            this.exceptionTypeFullName = serverException.TypeFullName;
        }

        if (innerException) {
            this.stack = innerException.stack;
        }
    }

    private static buildMessage(
        message: string,
        statusCode: number,
        response?: string
    ): string {
        let serverException = ServerException.tryParse(response);
        if (serverException)
            return serverException.Message || '';

        return `${message}\n\nStatus: ${statusCode}\nResponse:\n${response?.substring(0, Math.min(512, response.length))}`;
    }

    override toString(): string {
        return `HTTP Response:\n\n${this.response}\n\n${super.toString()}`;
    }
}

class ServerException {
    Data!: { [key: string]: string | null };
    TypeName?: string;
    TypeFullName?: string;
    Message?: string;

    public static tryParse(value: string | undefined): ServerException | null {
        if (!value)
            return null;

        try {
            let serverException: ServerException = JSON.parse(value);
            return serverException.TypeName ? serverException : null;
        } catch {
            return null;
        }
    }
}