//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.0.0.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import axios, { AxiosError } from 'axios';
import type { AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

export class ApiClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    getConfig( cancelToken?: CancelToken): Promise<AppConfig> {
        let url_ = this.baseUrl + "/api/app/config";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetConfig(_response);
        });
    }

    protected processGetConfig(response: AxiosResponse): Promise<AppConfig> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AppConfig.fromJS(resultData200);
            return Promise.resolve<AppConfig>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AppConfig>(null as any);
    }

    getState( cancelToken?: CancelToken): Promise<AppState> {
        let url_ = this.baseUrl + "/api/app/state";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetState(_response);
        });
    }

    protected processGetState(response: AxiosResponse): Promise<AppState> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AppState.fromJS(resultData200);
            return Promise.resolve<AppState>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AppState>(null as any);
    }

    connect(clientProfileId?: string | null | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/app/connect?";
        if (clientProfileId !== undefined && clientProfileId !== null)
            url_ += "clientProfileId=" + encodeURIComponent("" + clientProfileId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processConnect(_response);
        });
    }

    protected processConnect(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    diagnose(clientProfileId?: string | null | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/app/diagnose?";
        if (clientProfileId !== undefined && clientProfileId !== null)
            url_ += "clientProfileId=" + encodeURIComponent("" + clientProfileId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDiagnose(_response);
        });
    }

    protected processDiagnose(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    disconnect( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/app/disconnect";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDisconnect(_response);
        });
    }

    protected processDisconnect(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    addAccessKey(accessKey: string, cancelToken?: CancelToken): Promise<ClientProfile> {
        let url_ = this.baseUrl + "/api/app/access-keys?";
        if (accessKey === undefined || accessKey === null)
            throw new Error("The parameter 'accessKey' must be defined and cannot be null.");
        else
            url_ += "accessKey=" + encodeURIComponent("" + accessKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAddAccessKey(_response);
        });
    }

    protected processAddAccessKey(response: AxiosResponse): Promise<ClientProfile> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ClientProfile.fromJS(resultData200);
            return Promise.resolve<ClientProfile>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ClientProfile>(null as any);
    }

    clearLastError( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/app/clear-last-error";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processClearLastError(_response);
        });
    }

    protected processClearLastError(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    addTestServer( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/app/add-test-server";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAddTestServer(_response);
        });
    }

    protected processAddTestServer(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    setUserSettings(userSettings: UserSettings, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/app/user-settings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(userSettings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSetUserSettings(_response);
        });
    }

    protected processSetUserSettings(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    log( cancelToken?: CancelToken): Promise<string> {
        let url_ = this.baseUrl + "/api/app/log.txt";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processLog(_response);
        });
    }

    protected processLog(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<string>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }

    getInstalledApps( cancelToken?: CancelToken): Promise<DeviceAppInfo[]> {
        let url_ = this.baseUrl + "/api/app/installed-apps";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetInstalledApps(_response);
        });
    }

    protected processGetInstalledApps(response: AxiosResponse): Promise<DeviceAppInfo[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DeviceAppInfo.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<DeviceAppInfo[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DeviceAppInfo[]>(null as any);
    }

    getIpGroups( cancelToken?: CancelToken): Promise<IpGroup[]> {
        let url_ = this.baseUrl + "/api/app/ip-groups";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetIpGroups(_response);
        });
    }

    protected processGetIpGroups(response: AxiosResponse): Promise<IpGroup[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(IpGroup.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<IpGroup[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<IpGroup[]>(null as any);
    }

    updateClientProfile(clientProfileId: string, updateParams: ClientProfileUpdateParams, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/app/client-profiles/{clientProfileId}";
        if (clientProfileId === undefined || clientProfileId === null)
            throw new Error("The parameter 'clientProfileId' must be defined.");
        url_ = url_.replace("{clientProfileId}", encodeURIComponent("" + clientProfileId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateParams);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PATCH",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateClientProfile(_response);
        });
    }

    protected processUpdateClientProfile(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    deleteClientProfile(clientProfileId: string, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/app/client-profiles/{clientProfileId}";
        if (clientProfileId === undefined || clientProfileId === null)
            throw new Error("The parameter 'clientProfileId' must be defined.");
        url_ = url_.replace("{clientProfileId}", encodeURIComponent("" + clientProfileId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteClientProfile(_response);
        });
    }

    protected processDeleteClientProfile(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class AppConfig implements IAppConfig {
    features!: AppFeatures;
    settings!: AppSettings;
    state!: AppState;
    clientProfileItems!: ClientProfileItem[];

    constructor(data?: IAppConfig) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.features = new AppFeatures();
            this.settings = new AppSettings();
            this.state = new AppState();
            this.clientProfileItems = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.features = _data["features"] ? AppFeatures.fromJS(_data["features"]) : new AppFeatures();
            this.settings = _data["settings"] ? AppSettings.fromJS(_data["settings"]) : new AppSettings();
            this.state = _data["state"] ? AppState.fromJS(_data["state"]) : new AppState();
            if (Array.isArray(_data["clientProfileItems"])) {
                this.clientProfileItems = [] as any;
                for (let item of _data["clientProfileItems"])
                    this.clientProfileItems!.push(ClientProfileItem.fromJS(item));
            }
            else {
                this.clientProfileItems = <any>null;
            }
        }
    }

    static fromJS(data: any): AppConfig {
        data = typeof data === 'object' ? data : {};
        let result = new AppConfig();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["features"] = this.features ? this.features.toJSON() : <any>null;
        data["settings"] = this.settings ? this.settings.toJSON() : <any>null;
        data["state"] = this.state ? this.state.toJSON() : <any>null;
        if (Array.isArray(this.clientProfileItems)) {
            data["clientProfileItems"] = [];
            for (let item of this.clientProfileItems)
                data["clientProfileItems"].push(item.toJSON());
        }
        return data;
    }
}

export interface IAppConfig {
    features: AppFeatures;
    settings: AppSettings;
    state: AppState;
    clientProfileItems: ClientProfileItem[];
}

export class AppFeatures implements IAppFeatures {
    version!: string;
    testServerTokenId?: string | null;
    isExcludeAppsSupported!: boolean;
    isIncludeAppsSupported!: boolean;
    updateInfoUrl?: string | null;

    constructor(data?: IAppFeatures) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.version = _data["version"] !== undefined ? _data["version"] : <any>null;
            this.testServerTokenId = _data["testServerTokenId"] !== undefined ? _data["testServerTokenId"] : <any>null;
            this.isExcludeAppsSupported = _data["isExcludeAppsSupported"] !== undefined ? _data["isExcludeAppsSupported"] : <any>null;
            this.isIncludeAppsSupported = _data["isIncludeAppsSupported"] !== undefined ? _data["isIncludeAppsSupported"] : <any>null;
            this.updateInfoUrl = _data["updateInfoUrl"] !== undefined ? _data["updateInfoUrl"] : <any>null;
        }
    }

    static fromJS(data: any): AppFeatures {
        data = typeof data === 'object' ? data : {};
        let result = new AppFeatures();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["version"] = this.version !== undefined ? this.version : <any>null;
        data["testServerTokenId"] = this.testServerTokenId !== undefined ? this.testServerTokenId : <any>null;
        data["isExcludeAppsSupported"] = this.isExcludeAppsSupported !== undefined ? this.isExcludeAppsSupported : <any>null;
        data["isIncludeAppsSupported"] = this.isIncludeAppsSupported !== undefined ? this.isIncludeAppsSupported : <any>null;
        data["updateInfoUrl"] = this.updateInfoUrl !== undefined ? this.updateInfoUrl : <any>null;
        return data;
    }
}

export interface IAppFeatures {
    version: string;
    testServerTokenId?: string | null;
    isExcludeAppsSupported: boolean;
    isIncludeAppsSupported: boolean;
    updateInfoUrl?: string | null;
}

export class AppSettings implements IAppSettings {
    isQuickLaunchAdded!: boolean;
    isQuickLaunchRequested!: boolean;
    configTime!: Date;
    userSettings!: UserSettings;
    clientId!: string;
    lastCountryIpGroupId?: string | null;
    testServerTokenAutoAdded?: string | null;
    testServerAccessKey!: string;

    constructor(data?: IAppSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.userSettings = new UserSettings();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isQuickLaunchAdded = _data["isQuickLaunchAdded"] !== undefined ? _data["isQuickLaunchAdded"] : <any>null;
            this.isQuickLaunchRequested = _data["isQuickLaunchRequested"] !== undefined ? _data["isQuickLaunchRequested"] : <any>null;
            this.configTime = _data["configTime"] ? new Date(_data["configTime"].toString()) : <any>null;
            this.userSettings = _data["userSettings"] ? UserSettings.fromJS(_data["userSettings"]) : new UserSettings();
            this.clientId = _data["clientId"] !== undefined ? _data["clientId"] : <any>null;
            this.lastCountryIpGroupId = _data["lastCountryIpGroupId"] !== undefined ? _data["lastCountryIpGroupId"] : <any>null;
            this.testServerTokenAutoAdded = _data["testServerTokenAutoAdded"] !== undefined ? _data["testServerTokenAutoAdded"] : <any>null;
            this.testServerAccessKey = _data["testServerAccessKey"] !== undefined ? _data["testServerAccessKey"] : <any>null;
        }
    }

    static fromJS(data: any): AppSettings {
        data = typeof data === 'object' ? data : {};
        let result = new AppSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isQuickLaunchAdded"] = this.isQuickLaunchAdded !== undefined ? this.isQuickLaunchAdded : <any>null;
        data["isQuickLaunchRequested"] = this.isQuickLaunchRequested !== undefined ? this.isQuickLaunchRequested : <any>null;
        data["configTime"] = this.configTime ? this.configTime.toISOString() : <any>null;
        data["userSettings"] = this.userSettings ? this.userSettings.toJSON() : <any>null;
        data["clientId"] = this.clientId !== undefined ? this.clientId : <any>null;
        data["lastCountryIpGroupId"] = this.lastCountryIpGroupId !== undefined ? this.lastCountryIpGroupId : <any>null;
        data["testServerTokenAutoAdded"] = this.testServerTokenAutoAdded !== undefined ? this.testServerTokenAutoAdded : <any>null;
        data["testServerAccessKey"] = this.testServerAccessKey !== undefined ? this.testServerAccessKey : <any>null;
        return data;
    }
}

export interface IAppSettings {
    isQuickLaunchAdded: boolean;
    isQuickLaunchRequested: boolean;
    configTime: Date;
    userSettings: UserSettings;
    clientId: string;
    lastCountryIpGroupId?: string | null;
    testServerTokenAutoAdded?: string | null;
    testServerAccessKey: string;
}

export class UserSettings implements IUserSettings {
    logging!: AppLogSettings;
    cultureName!: string;
    defaultClientProfileId?: string | null;
    maxReconnectCount!: number;
    maxDatagramChannelCount!: number;
    tunnelClientCountry!: boolean;
    ipGroupFilters?: string[] | null;
    ipGroupFiltersMode!: FilterMode;
    customIpRanges?: string[] | null;
    appFilters?: string[] | null;
    appFiltersMode!: FilterMode;
    useUdpChannel!: boolean;
    dropUdpPackets!: boolean;
    excludeLocalNetwork!: boolean;
    packetCaptureIncludeIpRanges!: string[];
    packetCaptureExcludeIpRanges?: string[] | null;
    allowAnonymousTracker!: boolean;

    constructor(data?: IUserSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.logging = new AppLogSettings();
            this.packetCaptureIncludeIpRanges = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.logging = _data["logging"] ? AppLogSettings.fromJS(_data["logging"]) : new AppLogSettings();
            this.cultureName = _data["cultureName"] !== undefined ? _data["cultureName"] : <any>null;
            this.defaultClientProfileId = _data["defaultClientProfileId"] !== undefined ? _data["defaultClientProfileId"] : <any>null;
            this.maxReconnectCount = _data["maxReconnectCount"] !== undefined ? _data["maxReconnectCount"] : <any>null;
            this.maxDatagramChannelCount = _data["maxDatagramChannelCount"] !== undefined ? _data["maxDatagramChannelCount"] : <any>null;
            this.tunnelClientCountry = _data["tunnelClientCountry"] !== undefined ? _data["tunnelClientCountry"] : <any>null;
            if (Array.isArray(_data["ipGroupFilters"])) {
                this.ipGroupFilters = [] as any;
                for (let item of _data["ipGroupFilters"])
                    this.ipGroupFilters!.push(item);
            }
            else {
                this.ipGroupFilters = <any>null;
            }
            this.ipGroupFiltersMode = _data["ipGroupFiltersMode"] !== undefined ? _data["ipGroupFiltersMode"] : <any>null;
            if (Array.isArray(_data["customIpRanges"])) {
                this.customIpRanges = [] as any;
                for (let item of _data["customIpRanges"])
                    this.customIpRanges!.push(item);
            }
            else {
                this.customIpRanges = <any>null;
            }
            if (Array.isArray(_data["appFilters"])) {
                this.appFilters = [] as any;
                for (let item of _data["appFilters"])
                    this.appFilters!.push(item);
            }
            else {
                this.appFilters = <any>null;
            }
            this.appFiltersMode = _data["appFiltersMode"] !== undefined ? _data["appFiltersMode"] : <any>null;
            this.useUdpChannel = _data["useUdpChannel"] !== undefined ? _data["useUdpChannel"] : <any>null;
            this.dropUdpPackets = _data["dropUdpPackets"] !== undefined ? _data["dropUdpPackets"] : <any>null;
            this.excludeLocalNetwork = _data["excludeLocalNetwork"] !== undefined ? _data["excludeLocalNetwork"] : <any>null;
            if (Array.isArray(_data["packetCaptureIncludeIpRanges"])) {
                this.packetCaptureIncludeIpRanges = [] as any;
                for (let item of _data["packetCaptureIncludeIpRanges"])
                    this.packetCaptureIncludeIpRanges!.push(item);
            }
            else {
                this.packetCaptureIncludeIpRanges = <any>null;
            }
            if (Array.isArray(_data["packetCaptureExcludeIpRanges"])) {
                this.packetCaptureExcludeIpRanges = [] as any;
                for (let item of _data["packetCaptureExcludeIpRanges"])
                    this.packetCaptureExcludeIpRanges!.push(item);
            }
            else {
                this.packetCaptureExcludeIpRanges = <any>null;
            }
            this.allowAnonymousTracker = _data["allowAnonymousTracker"] !== undefined ? _data["allowAnonymousTracker"] : <any>null;
        }
    }

    static fromJS(data: any): UserSettings {
        data = typeof data === 'object' ? data : {};
        let result = new UserSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["logging"] = this.logging ? this.logging.toJSON() : <any>null;
        data["cultureName"] = this.cultureName !== undefined ? this.cultureName : <any>null;
        data["defaultClientProfileId"] = this.defaultClientProfileId !== undefined ? this.defaultClientProfileId : <any>null;
        data["maxReconnectCount"] = this.maxReconnectCount !== undefined ? this.maxReconnectCount : <any>null;
        data["maxDatagramChannelCount"] = this.maxDatagramChannelCount !== undefined ? this.maxDatagramChannelCount : <any>null;
        data["tunnelClientCountry"] = this.tunnelClientCountry !== undefined ? this.tunnelClientCountry : <any>null;
        if (Array.isArray(this.ipGroupFilters)) {
            data["ipGroupFilters"] = [];
            for (let item of this.ipGroupFilters)
                data["ipGroupFilters"].push(item);
        }
        data["ipGroupFiltersMode"] = this.ipGroupFiltersMode !== undefined ? this.ipGroupFiltersMode : <any>null;
        if (Array.isArray(this.customIpRanges)) {
            data["customIpRanges"] = [];
            for (let item of this.customIpRanges)
                data["customIpRanges"].push(item);
        }
        if (Array.isArray(this.appFilters)) {
            data["appFilters"] = [];
            for (let item of this.appFilters)
                data["appFilters"].push(item);
        }
        data["appFiltersMode"] = this.appFiltersMode !== undefined ? this.appFiltersMode : <any>null;
        data["useUdpChannel"] = this.useUdpChannel !== undefined ? this.useUdpChannel : <any>null;
        data["dropUdpPackets"] = this.dropUdpPackets !== undefined ? this.dropUdpPackets : <any>null;
        data["excludeLocalNetwork"] = this.excludeLocalNetwork !== undefined ? this.excludeLocalNetwork : <any>null;
        if (Array.isArray(this.packetCaptureIncludeIpRanges)) {
            data["packetCaptureIncludeIpRanges"] = [];
            for (let item of this.packetCaptureIncludeIpRanges)
                data["packetCaptureIncludeIpRanges"].push(item);
        }
        if (Array.isArray(this.packetCaptureExcludeIpRanges)) {
            data["packetCaptureExcludeIpRanges"] = [];
            for (let item of this.packetCaptureExcludeIpRanges)
                data["packetCaptureExcludeIpRanges"].push(item);
        }
        data["allowAnonymousTracker"] = this.allowAnonymousTracker !== undefined ? this.allowAnonymousTracker : <any>null;
        return data;
    }
}

export interface IUserSettings {
    logging: AppLogSettings;
    cultureName: string;
    defaultClientProfileId?: string | null;
    maxReconnectCount: number;
    maxDatagramChannelCount: number;
    tunnelClientCountry: boolean;
    ipGroupFilters?: string[] | null;
    ipGroupFiltersMode: FilterMode;
    customIpRanges?: string[] | null;
    appFilters?: string[] | null;
    appFiltersMode: FilterMode;
    useUdpChannel: boolean;
    dropUdpPackets: boolean;
    excludeLocalNetwork: boolean;
    packetCaptureIncludeIpRanges: string[];
    packetCaptureExcludeIpRanges?: string[] | null;
    allowAnonymousTracker: boolean;
}

export class AppLogSettings implements IAppLogSettings {
    logToConsole!: boolean;
    logToFile!: boolean;
    logVerbose!: boolean;
    logAnonymous!: boolean;

    constructor(data?: IAppLogSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.logToConsole = _data["logToConsole"] !== undefined ? _data["logToConsole"] : <any>null;
            this.logToFile = _data["logToFile"] !== undefined ? _data["logToFile"] : <any>null;
            this.logVerbose = _data["logVerbose"] !== undefined ? _data["logVerbose"] : <any>null;
            this.logAnonymous = _data["logAnonymous"] !== undefined ? _data["logAnonymous"] : <any>null;
        }
    }

    static fromJS(data: any): AppLogSettings {
        data = typeof data === 'object' ? data : {};
        let result = new AppLogSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["logToConsole"] = this.logToConsole !== undefined ? this.logToConsole : <any>null;
        data["logToFile"] = this.logToFile !== undefined ? this.logToFile : <any>null;
        data["logVerbose"] = this.logVerbose !== undefined ? this.logVerbose : <any>null;
        data["logAnonymous"] = this.logAnonymous !== undefined ? this.logAnonymous : <any>null;
        return data;
    }
}

export interface IAppLogSettings {
    logToConsole: boolean;
    logToFile: boolean;
    logVerbose: boolean;
    logAnonymous: boolean;
}

export enum FilterMode {
    All = "All",
    Exclude = "Exclude",
    Include = "Include",
}

export class AppState implements IAppState {
    configTime!: Date;
    connectRequestTime?: Date | null;
    connectionState!: AppConnectionState;
    lastError?: string | null;
    activeClientProfileId?: string | null;
    isIdle!: boolean;
    logExists!: boolean;
    lastActiveClientProfileId?: string | null;
    hasDiagnoseStarted!: boolean;
    hasDisconnectedByUser!: boolean;
    hasProblemDetected!: boolean;
    sessionStatus?: SessionStatus | null;
    speed!: Traffic;
    sessionTraffic!: Traffic;
    accountTraffic!: Traffic;
    clientIpGroup?: IpGroup | null;
    isWaitingForAd!: boolean;
    versionStatus!: VersionStatus;
    lastPublishInfo?: PublishInfo | null;

    constructor(data?: IAppState) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.speed = new Traffic();
            this.sessionTraffic = new Traffic();
            this.accountTraffic = new Traffic();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.configTime = _data["configTime"] ? new Date(_data["configTime"].toString()) : <any>null;
            this.connectRequestTime = _data["connectRequestTime"] ? new Date(_data["connectRequestTime"].toString()) : <any>null;
            this.connectionState = _data["connectionState"] !== undefined ? _data["connectionState"] : <any>null;
            this.lastError = _data["lastError"] !== undefined ? _data["lastError"] : <any>null;
            this.activeClientProfileId = _data["activeClientProfileId"] !== undefined ? _data["activeClientProfileId"] : <any>null;
            this.isIdle = _data["isIdle"] !== undefined ? _data["isIdle"] : <any>null;
            this.logExists = _data["logExists"] !== undefined ? _data["logExists"] : <any>null;
            this.lastActiveClientProfileId = _data["lastActiveClientProfileId"] !== undefined ? _data["lastActiveClientProfileId"] : <any>null;
            this.hasDiagnoseStarted = _data["hasDiagnoseStarted"] !== undefined ? _data["hasDiagnoseStarted"] : <any>null;
            this.hasDisconnectedByUser = _data["hasDisconnectedByUser"] !== undefined ? _data["hasDisconnectedByUser"] : <any>null;
            this.hasProblemDetected = _data["hasProblemDetected"] !== undefined ? _data["hasProblemDetected"] : <any>null;
            this.sessionStatus = _data["sessionStatus"] ? SessionStatus.fromJS(_data["sessionStatus"]) : <any>null;
            this.speed = _data["speed"] ? Traffic.fromJS(_data["speed"]) : new Traffic();
            this.sessionTraffic = _data["sessionTraffic"] ? Traffic.fromJS(_data["sessionTraffic"]) : new Traffic();
            this.accountTraffic = _data["accountTraffic"] ? Traffic.fromJS(_data["accountTraffic"]) : new Traffic();
            this.clientIpGroup = _data["clientIpGroup"] ? IpGroup.fromJS(_data["clientIpGroup"]) : <any>null;
            this.isWaitingForAd = _data["isWaitingForAd"] !== undefined ? _data["isWaitingForAd"] : <any>null;
            this.versionStatus = _data["versionStatus"] !== undefined ? _data["versionStatus"] : <any>null;
            this.lastPublishInfo = _data["lastPublishInfo"] ? PublishInfo.fromJS(_data["lastPublishInfo"]) : <any>null;
        }
    }

    static fromJS(data: any): AppState {
        data = typeof data === 'object' ? data : {};
        let result = new AppState();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["configTime"] = this.configTime ? this.configTime.toISOString() : <any>null;
        data["connectRequestTime"] = this.connectRequestTime ? this.connectRequestTime.toISOString() : <any>null;
        data["connectionState"] = this.connectionState !== undefined ? this.connectionState : <any>null;
        data["lastError"] = this.lastError !== undefined ? this.lastError : <any>null;
        data["activeClientProfileId"] = this.activeClientProfileId !== undefined ? this.activeClientProfileId : <any>null;
        data["isIdle"] = this.isIdle !== undefined ? this.isIdle : <any>null;
        data["logExists"] = this.logExists !== undefined ? this.logExists : <any>null;
        data["lastActiveClientProfileId"] = this.lastActiveClientProfileId !== undefined ? this.lastActiveClientProfileId : <any>null;
        data["hasDiagnoseStarted"] = this.hasDiagnoseStarted !== undefined ? this.hasDiagnoseStarted : <any>null;
        data["hasDisconnectedByUser"] = this.hasDisconnectedByUser !== undefined ? this.hasDisconnectedByUser : <any>null;
        data["hasProblemDetected"] = this.hasProblemDetected !== undefined ? this.hasProblemDetected : <any>null;
        data["sessionStatus"] = this.sessionStatus ? this.sessionStatus.toJSON() : <any>null;
        data["speed"] = this.speed ? this.speed.toJSON() : <any>null;
        data["sessionTraffic"] = this.sessionTraffic ? this.sessionTraffic.toJSON() : <any>null;
        data["accountTraffic"] = this.accountTraffic ? this.accountTraffic.toJSON() : <any>null;
        data["clientIpGroup"] = this.clientIpGroup ? this.clientIpGroup.toJSON() : <any>null;
        data["isWaitingForAd"] = this.isWaitingForAd !== undefined ? this.isWaitingForAd : <any>null;
        data["versionStatus"] = this.versionStatus !== undefined ? this.versionStatus : <any>null;
        data["lastPublishInfo"] = this.lastPublishInfo ? this.lastPublishInfo.toJSON() : <any>null;
        return data;
    }
}

export interface IAppState {
    configTime: Date;
    connectRequestTime?: Date | null;
    connectionState: AppConnectionState;
    lastError?: string | null;
    activeClientProfileId?: string | null;
    isIdle: boolean;
    logExists: boolean;
    lastActiveClientProfileId?: string | null;
    hasDiagnoseStarted: boolean;
    hasDisconnectedByUser: boolean;
    hasProblemDetected: boolean;
    sessionStatus?: SessionStatus | null;
    speed: Traffic;
    sessionTraffic: Traffic;
    accountTraffic: Traffic;
    clientIpGroup?: IpGroup | null;
    isWaitingForAd: boolean;
    versionStatus: VersionStatus;
    lastPublishInfo?: PublishInfo | null;
}

export enum AppConnectionState {
    None = "None",
    Initializing = "Initializing",
    Waiting = "Waiting",
    Diagnosing = "Diagnosing",
    Connecting = "Connecting",
    Connected = "Connected",
    Disconnecting = "Disconnecting",
}

export class SessionStatus implements ISessionStatus {
    errorCode!: SessionErrorCode;
    accessUsage?: AccessUsage | null;
    suppressedTo!: SessionSuppressType;
    suppressedBy!: SessionSuppressType;
    errorMessage?: string | null;

    constructor(data?: ISessionStatus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.errorCode = _data["errorCode"] !== undefined ? _data["errorCode"] : <any>null;
            this.accessUsage = _data["accessUsage"] ? AccessUsage.fromJS(_data["accessUsage"]) : <any>null;
            this.suppressedTo = _data["suppressedTo"] !== undefined ? _data["suppressedTo"] : <any>null;
            this.suppressedBy = _data["suppressedBy"] !== undefined ? _data["suppressedBy"] : <any>null;
            this.errorMessage = _data["errorMessage"] !== undefined ? _data["errorMessage"] : <any>null;
        }
    }

    static fromJS(data: any): SessionStatus {
        data = typeof data === 'object' ? data : {};
        let result = new SessionStatus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["errorCode"] = this.errorCode !== undefined ? this.errorCode : <any>null;
        data["accessUsage"] = this.accessUsage ? this.accessUsage.toJSON() : <any>null;
        data["suppressedTo"] = this.suppressedTo !== undefined ? this.suppressedTo : <any>null;
        data["suppressedBy"] = this.suppressedBy !== undefined ? this.suppressedBy : <any>null;
        data["errorMessage"] = this.errorMessage !== undefined ? this.errorMessage : <any>null;
        return data;
    }
}

export interface ISessionStatus {
    errorCode: SessionErrorCode;
    accessUsage?: AccessUsage | null;
    suppressedTo: SessionSuppressType;
    suppressedBy: SessionSuppressType;
    errorMessage?: string | null;
}

export enum SessionErrorCode {
    Ok = "Ok",
    GeneralError = "GeneralError",
    SessionClosed = "SessionClosed",
    SessionSuppressedBy = "SessionSuppressedBy",
    SessionError = "SessionError",
    AccessExpired = "AccessExpired",
    AccessTrafficOverflow = "AccessTrafficOverflow",
    AccessLocked = "AccessLocked",
    AccessError = "AccessError",
    Maintenance = "Maintenance",
    RedirectHost = "RedirectHost",
    UnsupportedClient = "UnsupportedClient",
    UnsupportedServer = "UnsupportedServer",
}

export class AccessUsage implements IAccessUsage {
    traffic!: Traffic;
    maxTraffic!: number;
    expirationTime?: Date | null;
    maxClientCount!: number;
    activeClientCount?: number | null;

    constructor(data?: IAccessUsage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.traffic = new Traffic();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.traffic = _data["traffic"] ? Traffic.fromJS(_data["traffic"]) : new Traffic();
            this.maxTraffic = _data["maxTraffic"] !== undefined ? _data["maxTraffic"] : <any>null;
            this.expirationTime = _data["expirationTime"] ? new Date(_data["expirationTime"].toString()) : <any>null;
            this.maxClientCount = _data["maxClientCount"] !== undefined ? _data["maxClientCount"] : <any>null;
            this.activeClientCount = _data["activeClientCount"] !== undefined ? _data["activeClientCount"] : <any>null;
        }
    }

    static fromJS(data: any): AccessUsage {
        data = typeof data === 'object' ? data : {};
        let result = new AccessUsage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["traffic"] = this.traffic ? this.traffic.toJSON() : <any>null;
        data["maxTraffic"] = this.maxTraffic !== undefined ? this.maxTraffic : <any>null;
        data["expirationTime"] = this.expirationTime ? this.expirationTime.toISOString() : <any>null;
        data["maxClientCount"] = this.maxClientCount !== undefined ? this.maxClientCount : <any>null;
        data["activeClientCount"] = this.activeClientCount !== undefined ? this.activeClientCount : <any>null;
        return data;
    }
}

export interface IAccessUsage {
    traffic: Traffic;
    maxTraffic: number;
    expirationTime?: Date | null;
    maxClientCount: number;
    activeClientCount?: number | null;
}

export class Traffic implements ITraffic {
    sentTraffic!: number;
    receivedTraffic!: number;
    sent!: number;
    received!: number;

    constructor(data?: ITraffic) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sentTraffic = _data["sentTraffic"] !== undefined ? _data["sentTraffic"] : <any>null;
            this.receivedTraffic = _data["receivedTraffic"] !== undefined ? _data["receivedTraffic"] : <any>null;
            this.sent = _data["sent"] !== undefined ? _data["sent"] : <any>null;
            this.received = _data["received"] !== undefined ? _data["received"] : <any>null;
        }
    }

    static fromJS(data: any): Traffic {
        data = typeof data === 'object' ? data : {};
        let result = new Traffic();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sentTraffic"] = this.sentTraffic !== undefined ? this.sentTraffic : <any>null;
        data["receivedTraffic"] = this.receivedTraffic !== undefined ? this.receivedTraffic : <any>null;
        data["sent"] = this.sent !== undefined ? this.sent : <any>null;
        data["received"] = this.received !== undefined ? this.received : <any>null;
        return data;
    }
}

export interface ITraffic {
    sentTraffic: number;
    receivedTraffic: number;
    sent: number;
    received: number;
}

export enum SessionSuppressType {
    None = "None",
    YourSelf = "YourSelf",
    Other = "Other",
}

export class IpGroup implements IIpGroup {
    ipGroupId!: string;
    ipGroupName!: string;

    constructor(data?: IIpGroup) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ipGroupId = _data["ipGroupId"] !== undefined ? _data["ipGroupId"] : <any>null;
            this.ipGroupName = _data["ipGroupName"] !== undefined ? _data["ipGroupName"] : <any>null;
        }
    }

    static fromJS(data: any): IpGroup {
        data = typeof data === 'object' ? data : {};
        let result = new IpGroup();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ipGroupId"] = this.ipGroupId !== undefined ? this.ipGroupId : <any>null;
        data["ipGroupName"] = this.ipGroupName !== undefined ? this.ipGroupName : <any>null;
        return data;
    }
}

export interface IIpGroup {
    ipGroupId: string;
    ipGroupName: string;
}

export enum VersionStatus {
    Unknown = "Unknown",
    Latest = "Latest",
    Old = "Old",
    Deprecated = "Deprecated",
}

export class PublishInfo implements IPublishInfo {
    version!: string;
    updateInfoUrl!: string;
    packageUrl!: string;
    installationPageUrl!: string;
    releaseDate!: Date;
    deprecatedVersion!: string;
    notificationDelay!: string;

    constructor(data?: IPublishInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.version = _data["version"] !== undefined ? _data["version"] : <any>null;
            this.updateInfoUrl = _data["updateInfoUrl"] !== undefined ? _data["updateInfoUrl"] : <any>null;
            this.packageUrl = _data["packageUrl"] !== undefined ? _data["packageUrl"] : <any>null;
            this.installationPageUrl = _data["installationPageUrl"] !== undefined ? _data["installationPageUrl"] : <any>null;
            this.releaseDate = _data["releaseDate"] ? new Date(_data["releaseDate"].toString()) : <any>null;
            this.deprecatedVersion = _data["deprecatedVersion"] !== undefined ? _data["deprecatedVersion"] : <any>null;
            this.notificationDelay = _data["notificationDelay"] !== undefined ? _data["notificationDelay"] : <any>null;
        }
    }

    static fromJS(data: any): PublishInfo {
        data = typeof data === 'object' ? data : {};
        let result = new PublishInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["version"] = this.version !== undefined ? this.version : <any>null;
        data["updateInfoUrl"] = this.updateInfoUrl !== undefined ? this.updateInfoUrl : <any>null;
        data["packageUrl"] = this.packageUrl !== undefined ? this.packageUrl : <any>null;
        data["installationPageUrl"] = this.installationPageUrl !== undefined ? this.installationPageUrl : <any>null;
        data["releaseDate"] = this.releaseDate ? this.releaseDate.toISOString() : <any>null;
        data["deprecatedVersion"] = this.deprecatedVersion !== undefined ? this.deprecatedVersion : <any>null;
        data["notificationDelay"] = this.notificationDelay !== undefined ? this.notificationDelay : <any>null;
        return data;
    }
}

export interface IPublishInfo {
    version: string;
    updateInfoUrl: string;
    packageUrl: string;
    installationPageUrl: string;
    releaseDate: Date;
    deprecatedVersion: string;
    notificationDelay: string;
}

export class ClientProfileItem implements IClientProfileItem {
    clientProfileId!: string;
    clientProfile!: ClientProfile;
    token!: Token;
    name?: string | null;

    constructor(data?: IClientProfileItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.clientProfile = new ClientProfile();
            this.token = new Token();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.clientProfileId = _data["clientProfileId"] !== undefined ? _data["clientProfileId"] : <any>null;
            this.clientProfile = _data["clientProfile"] ? ClientProfile.fromJS(_data["clientProfile"]) : new ClientProfile();
            this.token = _data["token"] ? Token.fromJS(_data["token"]) : new Token();
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
        }
    }

    static fromJS(data: any): ClientProfileItem {
        data = typeof data === 'object' ? data : {};
        let result = new ClientProfileItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientProfileId"] = this.clientProfileId !== undefined ? this.clientProfileId : <any>null;
        data["clientProfile"] = this.clientProfile ? this.clientProfile.toJSON() : <any>null;
        data["token"] = this.token ? this.token.toJSON() : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data;
    }
}

export interface IClientProfileItem {
    clientProfileId: string;
    clientProfile: ClientProfile;
    token: Token;
    name?: string | null;
}

export class ClientProfile implements IClientProfile {
    name?: string | null;
    clientProfileId!: string;
    tokenId!: string;

    constructor(data?: IClientProfile) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.clientProfileId = _data["clientProfileId"] !== undefined ? _data["clientProfileId"] : <any>null;
            this.tokenId = _data["tokenId"] !== undefined ? _data["tokenId"] : <any>null;
        }
    }

    static fromJS(data: any): ClientProfile {
        data = typeof data === 'object' ? data : {};
        let result = new ClientProfile();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["clientProfileId"] = this.clientProfileId !== undefined ? this.clientProfileId : <any>null;
        data["tokenId"] = this.tokenId !== undefined ? this.tokenId : <any>null;
        return data;
    }
}

export interface IClientProfile {
    name?: string | null;
    clientProfileId: string;
    tokenId: string;
}

export class Token implements IToken {
    name?: string | null;
    v!: number;
    sid!: number;
    tid!: string;
    sec!: string;
    isv!: boolean;
    hname!: string;
    hport!: number;
    ch!: string;
    pb!: boolean;
    url?: string | null;
    ep?: string[] | null;

    constructor(data?: IToken) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.v = _data["v"] !== undefined ? _data["v"] : <any>null;
            this.sid = _data["sid"] !== undefined ? _data["sid"] : <any>null;
            this.tid = _data["tid"] !== undefined ? _data["tid"] : <any>null;
            this.sec = _data["sec"] !== undefined ? _data["sec"] : <any>null;
            this.isv = _data["isv"] !== undefined ? _data["isv"] : <any>null;
            this.hname = _data["hname"] !== undefined ? _data["hname"] : <any>null;
            this.hport = _data["hport"] !== undefined ? _data["hport"] : <any>null;
            this.ch = _data["ch"] !== undefined ? _data["ch"] : <any>null;
            this.pb = _data["pb"] !== undefined ? _data["pb"] : <any>null;
            this.url = _data["url"] !== undefined ? _data["url"] : <any>null;
            if (Array.isArray(_data["ep"])) {
                this.ep = [] as any;
                for (let item of _data["ep"])
                    this.ep!.push(item);
            }
            else {
                this.ep = <any>null;
            }
        }
    }

    static fromJS(data: any): Token {
        data = typeof data === 'object' ? data : {};
        let result = new Token();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["v"] = this.v !== undefined ? this.v : <any>null;
        data["sid"] = this.sid !== undefined ? this.sid : <any>null;
        data["tid"] = this.tid !== undefined ? this.tid : <any>null;
        data["sec"] = this.sec !== undefined ? this.sec : <any>null;
        data["isv"] = this.isv !== undefined ? this.isv : <any>null;
        data["hname"] = this.hname !== undefined ? this.hname : <any>null;
        data["hport"] = this.hport !== undefined ? this.hport : <any>null;
        data["ch"] = this.ch !== undefined ? this.ch : <any>null;
        data["pb"] = this.pb !== undefined ? this.pb : <any>null;
        data["url"] = this.url !== undefined ? this.url : <any>null;
        if (Array.isArray(this.ep)) {
            data["ep"] = [];
            for (let item of this.ep)
                data["ep"].push(item);
        }
        return data;
    }
}

export interface IToken {
    name?: string | null;
    v: number;
    sid: number;
    tid: string;
    sec: string;
    isv: boolean;
    hname: string;
    hport: number;
    ch: string;
    pb: boolean;
    url?: string | null;
    ep?: string[] | null;
}

export class DeviceAppInfo implements IDeviceAppInfo {
    appId!: string;
    appName!: string;
    iconPng!: string;

    constructor(data?: IDeviceAppInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.appId = _data["appId"] !== undefined ? _data["appId"] : <any>null;
            this.appName = _data["appName"] !== undefined ? _data["appName"] : <any>null;
            this.iconPng = _data["iconPng"] !== undefined ? _data["iconPng"] : <any>null;
        }
    }

    static fromJS(data: any): DeviceAppInfo {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceAppInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["appId"] = this.appId !== undefined ? this.appId : <any>null;
        data["appName"] = this.appName !== undefined ? this.appName : <any>null;
        data["iconPng"] = this.iconPng !== undefined ? this.iconPng : <any>null;
        return data;
    }
}

export interface IDeviceAppInfo {
    appId: string;
    appName: string;
    iconPng: string;
}

export class ClientProfileUpdateParams implements IClientProfileUpdateParams {
    name?: string | null;

    constructor(data?: IClientProfileUpdateParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
        }
    }

    static fromJS(data: any): ClientProfileUpdateParams {
        data = typeof data === 'object' ? data : {};
        let result = new ClientProfileUpdateParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data;
    }
}

export interface IClientProfileUpdateParams {
    name?: string | null;
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

function isAxiosError(obj: any): obj is AxiosError {
    return obj && obj.isAxiosError === true;
}

export class ApiException extends Error {
    statusCode: number;
    response?: string;
    exceptionTypeName?: string;
    exceptionTypeFullName?: string;
    headers: any;
    data: any = {};

    constructor(
        message: string,
        statusCode: number,
        response?: any,
        headers?: any,
        innerException?: Error | null
    ) {
        if (!(response instanceof String)) response = JSON.stringify(response);
        super(ApiException.buildMessage(message, statusCode, response));
        Object.setPrototypeOf(this, ApiException.prototype);

        this.statusCode = statusCode;
        this.response = response;
        this.headers = headers;

        let serverException: ServerException | null = ServerException.tryParse(response);
        if (serverException) {
            Object.keys(serverException.Data).forEach((key) => {
                if (serverException)
                    this.data[key] = serverException.Data[key];
            });
            this.exceptionTypeName = serverException.TypeName;
            this.exceptionTypeFullName = serverException.TypeFullName;
        }

        if (innerException) {
            this.stack = innerException.stack;
        }
    }

    private static buildMessage(
        message: string,
        statusCode: number,
        response?: string
    ): string {
        let serverException = ServerException.tryParse(response);
        if (serverException)
            return serverException.Message || '';

        return `${message}\n\nStatus: ${statusCode}\nResponse:\n${response?.substring(0, Math.min(512, response.length))}`;
    }

    override toString(): string {
        return `HTTP Response:\n\n${this.response}\n\n${super.toString()}`;
    }
}

class ServerException {
    Data!: { [key: string]: string | null };
    TypeName?: string;
    TypeFullName?: string;
    Message?: string;

    public static tryParse(value: string | undefined): ServerException | null {
        if (!value)
            return null;

        try {
            let serverException: ServerException = JSON.parse(value);
            return serverException.TypeName ? serverException : null;
        } catch {
            return null;
        }
    }
}