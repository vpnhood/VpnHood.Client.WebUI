//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import axios, { AxiosError } from 'axios';
import type { AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

export class ApiClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    loadApp(loadAppParam: LoadAppParam, cancelToken?: CancelToken | undefined): Promise<LoadAppResponse> {
        let url_ = this.baseUrl + "/api/loadApp";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(loadAppParam);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processLoadApp(_response);
        });
    }

    protected processLoadApp(response: AxiosResponse): Promise<LoadAppResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = LoadAppResponse.fromJS(resultData200);
            return Promise.resolve<LoadAppResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<LoadAppResponse>(null as any);
    }

    addAccessKey(addClientProfileParam: AddClientProfileParam, cancelToken?: CancelToken | undefined): Promise<ClientProfile> {
        let url_ = this.baseUrl + "/api/addAccessKey";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(addClientProfileParam);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAddAccessKey(_response);
        });
    }

    protected processAddAccessKey(response: AxiosResponse): Promise<ClientProfile> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ClientProfile.fromJS(resultData200);
            return Promise.resolve<ClientProfile>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ClientProfile>(null as any);
    }

    connect(connectParam: ConnectParam, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/connect";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(connectParam);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processConnect(_response);
        });
    }

    protected processConnect(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    diagnose(connectParam: ConnectParam, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/diagnose";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(connectParam);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDiagnose(_response);
        });
    }

    protected processDiagnose(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    disconnect( cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/disconnect";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDisconnect(_response);
        });
    }

    protected processDisconnect(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    setClientProfile(setClientProfileParam: SetClientProfileParam, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/setClientProfile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(setClientProfileParam);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSetClientProfile(_response);
        });
    }

    protected processSetClientProfile(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    removeClientProfile(removeClientProfileParam: RemoveClientProfileParam, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/removeClientProfile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(removeClientProfileParam);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRemoveClientProfile(_response);
        });
    }

    protected processRemoveClientProfile(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    clearLastError( cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/clearLastError";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processClearLastError(_response);
        });
    }

    protected processClearLastError(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    addTestServer( cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/addTestServer";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAddTestServer(_response);
        });
    }

    protected processAddTestServer(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    setUserSettings(userSettings: UserSettings, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/setUserSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(userSettings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSetUserSettings(_response);
        });
    }

    protected processSetUserSettings(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    log( cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/log";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processLog(_response);
        });
    }

    protected processLog(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class LoadAppResponse implements ILoadAppResponse {
    features?: AppFeatures | undefined;
    settings?: AppSettings | undefined;
    state?: AppState | undefined;
    clientProfileItems?: ClientProfileItem[] | undefined;

    constructor(data?: ILoadAppResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.features = _data["features"] ? AppFeatures.fromJS(_data["features"]) : <any>undefined;
            this.settings = _data["settings"] ? AppSettings.fromJS(_data["settings"]) : <any>undefined;
            this.state = _data["state"] ? AppState.fromJS(_data["state"]) : <any>undefined;
            if (Array.isArray(_data["clientProfileItems"])) {
                this.clientProfileItems = [] as any;
                for (let item of _data["clientProfileItems"])
                    this.clientProfileItems!.push(ClientProfileItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LoadAppResponse {
        data = typeof data === 'object' ? data : {};
        let result = new LoadAppResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["features"] = this.features ? this.features.toJSON() : <any>undefined;
        data["settings"] = this.settings ? this.settings.toJSON() : <any>undefined;
        data["state"] = this.state ? this.state.toJSON() : <any>undefined;
        if (Array.isArray(this.clientProfileItems)) {
            data["clientProfileItems"] = [];
            for (let item of this.clientProfileItems)
                data["clientProfileItems"].push(item.toJSON());
        }
        return data;
    }
}

export interface ILoadAppResponse {
    features?: AppFeatures | undefined;
    settings?: AppSettings | undefined;
    state?: AppState | undefined;
    clientProfileItems?: ClientProfileItem[] | undefined;
}

export class AppFeatures implements IAppFeatures {
    version!: string;
    testServerTokenId?: string | undefined;
    isExcludeAppsSupported!: boolean;
    isIncludeAppsSupported!: boolean;
    updateInfoUrl?: string | undefined;

    constructor(data?: IAppFeatures) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.version = _data["version"];
            this.testServerTokenId = _data["testServerTokenId"];
            this.isExcludeAppsSupported = _data["isExcludeAppsSupported"];
            this.isIncludeAppsSupported = _data["isIncludeAppsSupported"];
            this.updateInfoUrl = _data["updateInfoUrl"];
        }
    }

    static fromJS(data: any): AppFeatures {
        data = typeof data === 'object' ? data : {};
        let result = new AppFeatures();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["version"] = this.version;
        data["testServerTokenId"] = this.testServerTokenId;
        data["isExcludeAppsSupported"] = this.isExcludeAppsSupported;
        data["isIncludeAppsSupported"] = this.isIncludeAppsSupported;
        data["updateInfoUrl"] = this.updateInfoUrl;
        return data;
    }
}

export interface IAppFeatures {
    version: string;
    testServerTokenId?: string | undefined;
    isExcludeAppsSupported: boolean;
    isIncludeAppsSupported: boolean;
    updateInfoUrl?: string | undefined;
}

export class AppSettings implements IAppSettings {
    userSettings!: UserSettings;
    clientId!: string;
    testServerToken!: Token;
    lastCountryIpGroupId?: string | undefined;
    testServerTokenAutoAdded?: string | undefined;
    testServerAccessKey!: string;

    constructor(data?: IAppSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.userSettings = new UserSettings();
            this.testServerToken = new Token();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userSettings = _data["userSettings"] ? UserSettings.fromJS(_data["userSettings"]) : new UserSettings();
            this.clientId = _data["clientId"];
            this.testServerToken = _data["testServerToken"] ? Token.fromJS(_data["testServerToken"]) : new Token();
            this.lastCountryIpGroupId = _data["lastCountryIpGroupId"];
            this.testServerTokenAutoAdded = _data["testServerTokenAutoAdded"];
            this.testServerAccessKey = _data["testServerAccessKey"];
        }
    }

    static fromJS(data: any): AppSettings {
        data = typeof data === 'object' ? data : {};
        let result = new AppSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userSettings"] = this.userSettings ? this.userSettings.toJSON() : <any>undefined;
        data["clientId"] = this.clientId;
        data["testServerToken"] = this.testServerToken ? this.testServerToken.toJSON() : <any>undefined;
        data["lastCountryIpGroupId"] = this.lastCountryIpGroupId;
        data["testServerTokenAutoAdded"] = this.testServerTokenAutoAdded;
        data["testServerAccessKey"] = this.testServerAccessKey;
        return data;
    }
}

export interface IAppSettings {
    userSettings: UserSettings;
    clientId: string;
    testServerToken: Token;
    lastCountryIpGroupId?: string | undefined;
    testServerTokenAutoAdded?: string | undefined;
    testServerAccessKey: string;
}

export class UserSettings implements IUserSettings {
    logging!: AppLogSettings;
    cultureName!: string;
    defaultClientProfileId?: string | undefined;
    maxReconnectCount!: number;
    maxDatagramChannelCount!: number;
    tunnelClientCountry!: boolean;
    ipGroupFilters?: string[] | undefined;
    ipGroupFiltersMode!: FilterMode;
    customIpRanges?: string[] | undefined;
    appFilters?: string[] | undefined;
    appFiltersMode!: FilterMode;
    useUdpChannel!: boolean;
    dropUdpPackets!: boolean;
    excludeLocalNetwork!: boolean;
    packetCaptureIncludeIpRanges!: string[];
    packetCaptureExcludeIpRanges?: string[] | undefined;
    allowAnonymousTracker!: boolean;

    constructor(data?: IUserSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.logging = new AppLogSettings();
            this.packetCaptureIncludeIpRanges = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.logging = _data["logging"] ? AppLogSettings.fromJS(_data["logging"]) : new AppLogSettings();
            this.cultureName = _data["cultureName"];
            this.defaultClientProfileId = _data["defaultClientProfileId"];
            this.maxReconnectCount = _data["maxReconnectCount"];
            this.maxDatagramChannelCount = _data["maxDatagramChannelCount"];
            this.tunnelClientCountry = _data["tunnelClientCountry"];
            if (Array.isArray(_data["ipGroupFilters"])) {
                this.ipGroupFilters = [] as any;
                for (let item of _data["ipGroupFilters"])
                    this.ipGroupFilters!.push(item);
            }
            this.ipGroupFiltersMode = _data["ipGroupFiltersMode"];
            if (Array.isArray(_data["customIpRanges"])) {
                this.customIpRanges = [] as any;
                for (let item of _data["customIpRanges"])
                    this.customIpRanges!.push(item);
            }
            if (Array.isArray(_data["appFilters"])) {
                this.appFilters = [] as any;
                for (let item of _data["appFilters"])
                    this.appFilters!.push(item);
            }
            this.appFiltersMode = _data["appFiltersMode"];
            this.useUdpChannel = _data["useUdpChannel"];
            this.dropUdpPackets = _data["dropUdpPackets"];
            this.excludeLocalNetwork = _data["excludeLocalNetwork"];
            if (Array.isArray(_data["packetCaptureIncludeIpRanges"])) {
                this.packetCaptureIncludeIpRanges = [] as any;
                for (let item of _data["packetCaptureIncludeIpRanges"])
                    this.packetCaptureIncludeIpRanges!.push(item);
            }
            if (Array.isArray(_data["packetCaptureExcludeIpRanges"])) {
                this.packetCaptureExcludeIpRanges = [] as any;
                for (let item of _data["packetCaptureExcludeIpRanges"])
                    this.packetCaptureExcludeIpRanges!.push(item);
            }
            this.allowAnonymousTracker = _data["allowAnonymousTracker"];
        }
    }

    static fromJS(data: any): UserSettings {
        data = typeof data === 'object' ? data : {};
        let result = new UserSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["logging"] = this.logging ? this.logging.toJSON() : <any>undefined;
        data["cultureName"] = this.cultureName;
        data["defaultClientProfileId"] = this.defaultClientProfileId;
        data["maxReconnectCount"] = this.maxReconnectCount;
        data["maxDatagramChannelCount"] = this.maxDatagramChannelCount;
        data["tunnelClientCountry"] = this.tunnelClientCountry;
        if (Array.isArray(this.ipGroupFilters)) {
            data["ipGroupFilters"] = [];
            for (let item of this.ipGroupFilters)
                data["ipGroupFilters"].push(item);
        }
        data["ipGroupFiltersMode"] = this.ipGroupFiltersMode;
        if (Array.isArray(this.customIpRanges)) {
            data["customIpRanges"] = [];
            for (let item of this.customIpRanges)
                data["customIpRanges"].push(item);
        }
        if (Array.isArray(this.appFilters)) {
            data["appFilters"] = [];
            for (let item of this.appFilters)
                data["appFilters"].push(item);
        }
        data["appFiltersMode"] = this.appFiltersMode;
        data["useUdpChannel"] = this.useUdpChannel;
        data["dropUdpPackets"] = this.dropUdpPackets;
        data["excludeLocalNetwork"] = this.excludeLocalNetwork;
        if (Array.isArray(this.packetCaptureIncludeIpRanges)) {
            data["packetCaptureIncludeIpRanges"] = [];
            for (let item of this.packetCaptureIncludeIpRanges)
                data["packetCaptureIncludeIpRanges"].push(item);
        }
        if (Array.isArray(this.packetCaptureExcludeIpRanges)) {
            data["packetCaptureExcludeIpRanges"] = [];
            for (let item of this.packetCaptureExcludeIpRanges)
                data["packetCaptureExcludeIpRanges"].push(item);
        }
        data["allowAnonymousTracker"] = this.allowAnonymousTracker;
        return data;
    }
}

export interface IUserSettings {
    logging: AppLogSettings;
    cultureName: string;
    defaultClientProfileId?: string | undefined;
    maxReconnectCount: number;
    maxDatagramChannelCount: number;
    tunnelClientCountry: boolean;
    ipGroupFilters?: string[] | undefined;
    ipGroupFiltersMode: FilterMode;
    customIpRanges?: string[] | undefined;
    appFilters?: string[] | undefined;
    appFiltersMode: FilterMode;
    useUdpChannel: boolean;
    dropUdpPackets: boolean;
    excludeLocalNetwork: boolean;
    packetCaptureIncludeIpRanges: string[];
    packetCaptureExcludeIpRanges?: string[] | undefined;
    allowAnonymousTracker: boolean;
}

export class AppLogSettings implements IAppLogSettings {
    logToConsole!: boolean;
    logToFile!: boolean;
    logVerbose!: boolean;
    logAnonymous!: boolean;

    constructor(data?: IAppLogSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.logToConsole = _data["logToConsole"];
            this.logToFile = _data["logToFile"];
            this.logVerbose = _data["logVerbose"];
            this.logAnonymous = _data["logAnonymous"];
        }
    }

    static fromJS(data: any): AppLogSettings {
        data = typeof data === 'object' ? data : {};
        let result = new AppLogSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["logToConsole"] = this.logToConsole;
        data["logToFile"] = this.logToFile;
        data["logVerbose"] = this.logVerbose;
        data["logAnonymous"] = this.logAnonymous;
        return data;
    }
}

export interface IAppLogSettings {
    logToConsole: boolean;
    logToFile: boolean;
    logVerbose: boolean;
    logAnonymous: boolean;
}

export enum FilterMode {
    All = "All",
    Exclude = "Exclude",
    Include = "Include",
}

export class Token implements IToken {
    name?: string | undefined;
    v!: number;
    sid!: number;
    tid!: string;
    sec!: string;
    isv!: boolean;
    hname!: string;
    hport!: number;
    ch!: string;
    pb!: boolean;
    url?: string | undefined;
    ep?: string[] | undefined;

    constructor(data?: IToken) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.v = _data["v"];
            this.sid = _data["sid"];
            this.tid = _data["tid"];
            this.sec = _data["sec"];
            this.isv = _data["isv"];
            this.hname = _data["hname"];
            this.hport = _data["hport"];
            this.ch = _data["ch"];
            this.pb = _data["pb"];
            this.url = _data["url"];
            if (Array.isArray(_data["ep"])) {
                this.ep = [] as any;
                for (let item of _data["ep"])
                    this.ep!.push(item);
            }
        }
    }

    static fromJS(data: any): Token {
        data = typeof data === 'object' ? data : {};
        let result = new Token();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["v"] = this.v;
        data["sid"] = this.sid;
        data["tid"] = this.tid;
        data["sec"] = this.sec;
        data["isv"] = this.isv;
        data["hname"] = this.hname;
        data["hport"] = this.hport;
        data["ch"] = this.ch;
        data["pb"] = this.pb;
        data["url"] = this.url;
        if (Array.isArray(this.ep)) {
            data["ep"] = [];
            for (let item of this.ep)
                data["ep"].push(item);
        }
        return data;
    }
}

export interface IToken {
    name?: string | undefined;
    v: number;
    sid: number;
    tid: string;
    sec: string;
    isv: boolean;
    hname: string;
    hport: number;
    ch: string;
    pb: boolean;
    url?: string | undefined;
    ep?: string[] | undefined;
}

export class AppState implements IAppState {
    connectionState!: AppConnectionState;
    lastError?: string | undefined;
    activeClientProfileId?: string | undefined;
    defaultClientProfileId?: string | undefined;
    isIdle!: boolean;
    logExists!: boolean;
    lastActiveClientProfileId?: string | undefined;
    hasDiagnoseStarted!: boolean;
    hasDisconnectedByUser!: boolean;
    hasProblemDetected!: boolean;
    sessionStatus?: SessionStatus | undefined;
    speed!: Traffic;
    sessionTraffic!: Traffic;
    accountTraffic!: Traffic;
    clientIpGroup?: IpGroup | undefined;
    isWaitingForAd!: boolean;
    versionStatus!: VersionStatus;
    lastPublishInfo?: PublishInfo | undefined;

    constructor(data?: IAppState) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.speed = new Traffic();
            this.sessionTraffic = new Traffic();
            this.accountTraffic = new Traffic();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.connectionState = _data["connectionState"];
            this.lastError = _data["lastError"];
            this.activeClientProfileId = _data["activeClientProfileId"];
            this.defaultClientProfileId = _data["defaultClientProfileId"];
            this.isIdle = _data["isIdle"];
            this.logExists = _data["logExists"];
            this.lastActiveClientProfileId = _data["lastActiveClientProfileId"];
            this.hasDiagnoseStarted = _data["hasDiagnoseStarted"];
            this.hasDisconnectedByUser = _data["hasDisconnectedByUser"];
            this.hasProblemDetected = _data["hasProblemDetected"];
            this.sessionStatus = _data["sessionStatus"] ? SessionStatus.fromJS(_data["sessionStatus"]) : <any>undefined;
            this.speed = _data["speed"] ? Traffic.fromJS(_data["speed"]) : new Traffic();
            this.sessionTraffic = _data["sessionTraffic"] ? Traffic.fromJS(_data["sessionTraffic"]) : new Traffic();
            this.accountTraffic = _data["accountTraffic"] ? Traffic.fromJS(_data["accountTraffic"]) : new Traffic();
            this.clientIpGroup = _data["clientIpGroup"] ? IpGroup.fromJS(_data["clientIpGroup"]) : <any>undefined;
            this.isWaitingForAd = _data["isWaitingForAd"];
            this.versionStatus = _data["versionStatus"];
            this.lastPublishInfo = _data["lastPublishInfo"] ? PublishInfo.fromJS(_data["lastPublishInfo"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AppState {
        data = typeof data === 'object' ? data : {};
        let result = new AppState();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["connectionState"] = this.connectionState;
        data["lastError"] = this.lastError;
        data["activeClientProfileId"] = this.activeClientProfileId;
        data["defaultClientProfileId"] = this.defaultClientProfileId;
        data["isIdle"] = this.isIdle;
        data["logExists"] = this.logExists;
        data["lastActiveClientProfileId"] = this.lastActiveClientProfileId;
        data["hasDiagnoseStarted"] = this.hasDiagnoseStarted;
        data["hasDisconnectedByUser"] = this.hasDisconnectedByUser;
        data["hasProblemDetected"] = this.hasProblemDetected;
        data["sessionStatus"] = this.sessionStatus ? this.sessionStatus.toJSON() : <any>undefined;
        data["speed"] = this.speed ? this.speed.toJSON() : <any>undefined;
        data["sessionTraffic"] = this.sessionTraffic ? this.sessionTraffic.toJSON() : <any>undefined;
        data["accountTraffic"] = this.accountTraffic ? this.accountTraffic.toJSON() : <any>undefined;
        data["clientIpGroup"] = this.clientIpGroup ? this.clientIpGroup.toJSON() : <any>undefined;
        data["isWaitingForAd"] = this.isWaitingForAd;
        data["versionStatus"] = this.versionStatus;
        data["lastPublishInfo"] = this.lastPublishInfo ? this.lastPublishInfo.toJSON() : <any>undefined;
        return data;
    }
}

export interface IAppState {
    connectionState: AppConnectionState;
    lastError?: string | undefined;
    activeClientProfileId?: string | undefined;
    defaultClientProfileId?: string | undefined;
    isIdle: boolean;
    logExists: boolean;
    lastActiveClientProfileId?: string | undefined;
    hasDiagnoseStarted: boolean;
    hasDisconnectedByUser: boolean;
    hasProblemDetected: boolean;
    sessionStatus?: SessionStatus | undefined;
    speed: Traffic;
    sessionTraffic: Traffic;
    accountTraffic: Traffic;
    clientIpGroup?: IpGroup | undefined;
    isWaitingForAd: boolean;
    versionStatus: VersionStatus;
    lastPublishInfo?: PublishInfo | undefined;
}

export enum AppConnectionState {
    None = "None",
    Waiting = "Waiting",
    Diagnosing = "Diagnosing",
    Connecting = "Connecting",
    Connected = "Connected",
    Disconnecting = "Disconnecting",
}

export class SessionStatus implements ISessionStatus {
    errorCode!: SessionErrorCode;
    accessUsage?: AccessUsage | undefined;
    suppressedTo!: SessionSuppressType;
    suppressedBy!: SessionSuppressType;
    errorMessage?: string | undefined;

    constructor(data?: ISessionStatus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.errorCode = _data["errorCode"];
            this.accessUsage = _data["accessUsage"] ? AccessUsage.fromJS(_data["accessUsage"]) : <any>undefined;
            this.suppressedTo = _data["suppressedTo"];
            this.suppressedBy = _data["suppressedBy"];
            this.errorMessage = _data["errorMessage"];
        }
    }

    static fromJS(data: any): SessionStatus {
        data = typeof data === 'object' ? data : {};
        let result = new SessionStatus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["errorCode"] = this.errorCode;
        data["accessUsage"] = this.accessUsage ? this.accessUsage.toJSON() : <any>undefined;
        data["suppressedTo"] = this.suppressedTo;
        data["suppressedBy"] = this.suppressedBy;
        data["errorMessage"] = this.errorMessage;
        return data;
    }
}

export interface ISessionStatus {
    errorCode: SessionErrorCode;
    accessUsage?: AccessUsage | undefined;
    suppressedTo: SessionSuppressType;
    suppressedBy: SessionSuppressType;
    errorMessage?: string | undefined;
}

export enum SessionErrorCode {
    Ok = "Ok",
    GeneralError = "GeneralError",
    SessionClosed = "SessionClosed",
    SessionSuppressedBy = "SessionSuppressedBy",
    SessionError = "SessionError",
    AccessExpired = "AccessExpired",
    AccessTrafficOverflow = "AccessTrafficOverflow",
    AccessLocked = "AccessLocked",
    AccessError = "AccessError",
    Maintenance = "Maintenance",
    RedirectHost = "RedirectHost",
    UnsupportedClient = "UnsupportedClient",
    UnsupportedServer = "UnsupportedServer",
}

export class AccessUsage implements IAccessUsage {
    traffic!: Traffic;
    maxTraffic!: number;
    expirationTime?: Date | undefined;
    maxClientCount!: number;
    activeClientCount?: number | undefined;

    constructor(data?: IAccessUsage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.traffic = new Traffic();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.traffic = _data["traffic"] ? Traffic.fromJS(_data["traffic"]) : new Traffic();
            this.maxTraffic = _data["maxTraffic"];
            this.expirationTime = _data["expirationTime"] ? new Date(_data["expirationTime"].toString()) : <any>undefined;
            this.maxClientCount = _data["maxClientCount"];
            this.activeClientCount = _data["activeClientCount"];
        }
    }

    static fromJS(data: any): AccessUsage {
        data = typeof data === 'object' ? data : {};
        let result = new AccessUsage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["traffic"] = this.traffic ? this.traffic.toJSON() : <any>undefined;
        data["maxTraffic"] = this.maxTraffic;
        data["expirationTime"] = this.expirationTime ? this.expirationTime.toISOString() : <any>undefined;
        data["maxClientCount"] = this.maxClientCount;
        data["activeClientCount"] = this.activeClientCount;
        return data;
    }
}

export interface IAccessUsage {
    traffic: Traffic;
    maxTraffic: number;
    expirationTime?: Date | undefined;
    maxClientCount: number;
    activeClientCount?: number | undefined;
}

export class Traffic implements ITraffic {
    sentTraffic!: number;
    receivedTraffic!: number;
    sent!: number;
    received!: number;

    constructor(data?: ITraffic) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sentTraffic = _data["sentTraffic"];
            this.receivedTraffic = _data["receivedTraffic"];
            this.sent = _data["sent"];
            this.received = _data["received"];
        }
    }

    static fromJS(data: any): Traffic {
        data = typeof data === 'object' ? data : {};
        let result = new Traffic();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sentTraffic"] = this.sentTraffic;
        data["receivedTraffic"] = this.receivedTraffic;
        data["sent"] = this.sent;
        data["received"] = this.received;
        return data;
    }
}

export interface ITraffic {
    sentTraffic: number;
    receivedTraffic: number;
    sent: number;
    received: number;
}

export enum SessionSuppressType {
    None = "None",
    YourSelf = "YourSelf",
    Other = "Other",
}

export class IpGroup implements IIpGroup {
    ipGroupId!: string;
    ipGroupName!: string;

    constructor(data?: IIpGroup) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ipGroupId = _data["ipGroupId"];
            this.ipGroupName = _data["ipGroupName"];
        }
    }

    static fromJS(data: any): IpGroup {
        data = typeof data === 'object' ? data : {};
        let result = new IpGroup();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ipGroupId"] = this.ipGroupId;
        data["ipGroupName"] = this.ipGroupName;
        return data;
    }
}

export interface IIpGroup {
    ipGroupId: string;
    ipGroupName: string;
}

export enum VersionStatus {
    Unknown = "Unknown",
    Latest = "Latest",
    Old = "Old",
    Deprecated = "Deprecated",
}

export class PublishInfo implements IPublishInfo {
    version!: string;
    updateInfoUrl!: string;
    packageUrl!: string;
    installationPageUrl!: string;
    releaseDate!: Date;
    deprecatedVersion!: string;
    notificationDelay!: string;

    constructor(data?: IPublishInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.version = _data["version"];
            this.updateInfoUrl = _data["updateInfoUrl"];
            this.packageUrl = _data["packageUrl"];
            this.installationPageUrl = _data["installationPageUrl"];
            this.releaseDate = _data["releaseDate"] ? new Date(_data["releaseDate"].toString()) : <any>undefined;
            this.deprecatedVersion = _data["deprecatedVersion"];
            this.notificationDelay = _data["notificationDelay"];
        }
    }

    static fromJS(data: any): PublishInfo {
        data = typeof data === 'object' ? data : {};
        let result = new PublishInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["version"] = this.version;
        data["updateInfoUrl"] = this.updateInfoUrl;
        data["packageUrl"] = this.packageUrl;
        data["installationPageUrl"] = this.installationPageUrl;
        data["releaseDate"] = this.releaseDate ? this.releaseDate.toISOString() : <any>undefined;
        data["deprecatedVersion"] = this.deprecatedVersion;
        data["notificationDelay"] = this.notificationDelay;
        return data;
    }
}

export interface IPublishInfo {
    version: string;
    updateInfoUrl: string;
    packageUrl: string;
    installationPageUrl: string;
    releaseDate: Date;
    deprecatedVersion: string;
    notificationDelay: string;
}

export class ClientProfileItem implements IClientProfileItem {
    id!: string;
    clientProfile!: ClientProfile;
    token!: Token;

    constructor(data?: IClientProfileItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.clientProfile = new ClientProfile();
            this.token = new Token();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.clientProfile = _data["clientProfile"] ? ClientProfile.fromJS(_data["clientProfile"]) : new ClientProfile();
            this.token = _data["token"] ? Token.fromJS(_data["token"]) : new Token();
        }
    }

    static fromJS(data: any): ClientProfileItem {
        data = typeof data === 'object' ? data : {};
        let result = new ClientProfileItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["clientProfile"] = this.clientProfile ? this.clientProfile.toJSON() : <any>undefined;
        data["token"] = this.token ? this.token.toJSON() : <any>undefined;
        return data;
    }
}

export interface IClientProfileItem {
    id: string;
    clientProfile: ClientProfile;
    token: Token;
}

export class ClientProfile implements IClientProfile {
    name?: string | undefined;
    clientProfileId!: string;
    tokenId!: string;

    constructor(data?: IClientProfile) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.clientProfileId = _data["clientProfileId"];
            this.tokenId = _data["tokenId"];
        }
    }

    static fromJS(data: any): ClientProfile {
        data = typeof data === 'object' ? data : {};
        let result = new ClientProfile();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["clientProfileId"] = this.clientProfileId;
        data["tokenId"] = this.tokenId;
        return data;
    }
}

export interface IClientProfile {
    name?: string | undefined;
    clientProfileId: string;
    tokenId: string;
}

export class LoadAppParam implements ILoadAppParam {
    withFeatures!: boolean;
    withState!: boolean;
    withSettings!: boolean;
    withClientProfileItems!: boolean;

    constructor(data?: ILoadAppParam) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.withFeatures = _data["withFeatures"];
            this.withState = _data["withState"];
            this.withSettings = _data["withSettings"];
            this.withClientProfileItems = _data["withClientProfileItems"];
        }
    }

    static fromJS(data: any): LoadAppParam {
        data = typeof data === 'object' ? data : {};
        let result = new LoadAppParam();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["withFeatures"] = this.withFeatures;
        data["withState"] = this.withState;
        data["withSettings"] = this.withSettings;
        data["withClientProfileItems"] = this.withClientProfileItems;
        return data;
    }
}

export interface ILoadAppParam {
    withFeatures: boolean;
    withState: boolean;
    withSettings: boolean;
    withClientProfileItems: boolean;
}

export class AddClientProfileParam implements IAddClientProfileParam {
    accessKey!: string;

    constructor(data?: IAddClientProfileParam) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessKey = _data["accessKey"];
        }
    }

    static fromJS(data: any): AddClientProfileParam {
        data = typeof data === 'object' ? data : {};
        let result = new AddClientProfileParam();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessKey"] = this.accessKey;
        return data;
    }
}

export interface IAddClientProfileParam {
    accessKey: string;
}

export class ConnectParam implements IConnectParam {
    clientProfileId!: string;

    constructor(data?: IConnectParam) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.clientProfileId = _data["clientProfileId"];
        }
    }

    static fromJS(data: any): ConnectParam {
        data = typeof data === 'object' ? data : {};
        let result = new ConnectParam();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientProfileId"] = this.clientProfileId;
        return data;
    }
}

export interface IConnectParam {
    clientProfileId: string;
}

export class SetClientProfileParam implements ISetClientProfileParam {
    clientProfile!: ClientProfile;

    constructor(data?: ISetClientProfileParam) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.clientProfile = new ClientProfile();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.clientProfile = _data["clientProfile"] ? ClientProfile.fromJS(_data["clientProfile"]) : new ClientProfile();
        }
    }

    static fromJS(data: any): SetClientProfileParam {
        data = typeof data === 'object' ? data : {};
        let result = new SetClientProfileParam();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientProfile"] = this.clientProfile ? this.clientProfile.toJSON() : <any>undefined;
        return data;
    }
}

export interface ISetClientProfileParam {
    clientProfile: ClientProfile;
}

export class RemoveClientProfileParam implements IRemoveClientProfileParam {
    clientProfileId!: string;

    constructor(data?: IRemoveClientProfileParam) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.clientProfileId = _data["clientProfileId"];
        }
    }

    static fromJS(data: any): RemoveClientProfileParam {
        data = typeof data === 'object' ? data : {};
        let result = new RemoveClientProfileParam();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientProfileId"] = this.clientProfileId;
        return data;
    }
}

export interface IRemoveClientProfileParam {
    clientProfileId: string;
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

function isAxiosError(obj: any | undefined): obj is AxiosError {
    return obj && obj.isAxiosError === true;
}